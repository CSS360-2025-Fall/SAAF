- Hard-coded game rules: A lot of the game values and responses are written directly into the command files. If we ever want to change the
rules or add new games, we’d have to manually edit multiple parts of the code instead of adjusting them in one place.
- Lack of modular code: Each game’s logic is kind of tied into the main bot commands instead of being separated into modules. This makes it
harder to reuse or add new games since we’d have to rewrite or copy a lot of the same logic.
- No automated testing: There aren’t any tests to check if the slash commands or game logic are working correctly. This means if we change 
something, we might break another feature without noticing.
- No logging: The bot doesn’t log errors or track how often commands are used, so it’s hard to debug problems or see what games people play
the most.
These issues show the kind of technical debt that builds up when a project grows quickly without structure. It connects to what we talked
about in class: making code maintainable and testable instead of patching fixes as we go.
ESLint:
- Poor data sanitization before inserting to DB (unsafe operations)
  - There should be some sort of rate limiting on the ability to modify the database in any way. As it stands, the database is secure, but there could potentially be a spam/DOS attack that we would have no way of dealing with.
- ESLint is unhappy with the complexity of our app.js file. This could cause security issues and general extensibility issues in the future.
